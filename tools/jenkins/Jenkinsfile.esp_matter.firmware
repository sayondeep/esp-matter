// node('master') {
//     stage('Choose Docker') {
//         script {
//             checkout scm
//             //product_choices = sh (script: 'for product in ${WORKSPACE}/examples/*/main; do echo $product | sed "s="${WORKSPACE}"/products/==" | sed "s=/main==" ; done;', returnStdout:true).trim()
//         }
//     }
// }
pipeline {
    agent {
        docker {
            image 'registry.hub.docker.com/espressif/esp-matter:latest'
            // registryUrl 'https://gitlab.espressif.cn:5050'
            // registryCredentialsId 'JENKINS_GITLAB_USER_CREDENTIALS'
            alwaysPull true
        }
    }
    options {
        timeout(time: 2, unit: 'HOURS')
    }
    parameters {
        // choice(name: 'product', choices: "${product_choices}", description: 'Product choices')
        // choice(name: 'chip', choices:['esp32c3', 'esp32', 'esp32h2', 'esp32c2'], description: 'Chips')
        // string(name: 'esp_matter_branch', defaultValue: 'main', description: 'Branch to be used for esp-matter')
    }
    environment {
        REPOS_PATH="/opt/espressif"
        IDF_PATH="${REPOS_PATH}/esp-idf"
        ESP_MATTER_PATH="${REPOS_PATH}/esp-matter"
       // ESP_SECURE_CERT_PATH="${REPOS_PATH}/esp_secure_cert_mgr"
        // PROJECT_VER_SUFFIX="${BUILD_NUMBER}"
    }
    stages {
        stage('Setup') {
            steps {
                script {
                        // currentBuild.displayName = "${BUILD_TAG}"
                        currentBuild.description = "esp-matter Setup"
                }
                println('Running esp-matter Setup...')
                catchError() {
                    script {
                        // package_name = "esp_matter_firmware_${product}_${chip}"
                        // package_name = package_name + "_${BUILD_NUMBER}"
                        // env.PACKAGE_NAME = package_name
                        // env.PACKAGE_PATH = "${REPOS_PATH}/${PACKAGE_NAME}"
                        // echo "Package name: ${PACKAGE_NAME}"

                       // def esp_matter = load "${WORKSPACE}/tools/jenkins/esp_matter.groovy"
                      //  esp_matter.setup_directories_firmware()
                      //  esp_matter.setup_directories_script()
                      //  esp_matter.setup_directories_tools()
                      //  esp_matter.setup_environment()
                    }
                }
            }
            post {
                success {
                    echo 'Success for setup'
                }
                failure {
                    echo 'Failure for setup'
                    error('Failure for setup. Abort.')
                }
            }
        }
        stage("Build product") {
            steps {
                println('Build ${product} product binary for ${chip}.')
                catchError() {
                    script {
                        def esp_matter = load "${WORKSPACE}/tools/jenkins/esp_matter.groovy"

                       // env.FIRMWARE_TYPE = "Evaluation"
                        esp_matter.firmware_build()
                       // esp_matter.firmware_build_save()
                    }
                }
            }
            post {
                success {
                    echo 'Success for build product'
                }
                failure {
                    echo 'Failure for build product'
                    error('Failure for build product. Abort.')
                }
            }
        }

        // stage('Cleanup') {
        //     steps {
        //         echo 'Build Clean up.'
        //     }
        //     post {
        //         always {
        //             cleanWs()
        //         }
        //         success {
        //             echo 'Success for cleanup'
        //         }
        //         failure {
        //             echo 'Failure for cleanup'
        //             error('Failure for cleanup. Abort.')
        //         }
        //     }
        // }
    }
    post {
        always {
            echo 'Cleanup post'
            cleanWs()
        }
    }
}

